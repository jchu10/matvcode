function [lookingTimes, valid, oofDiffs, qualitative, lookingAtStart, msArray, trialStartsOut] = ...
    read_lookingtime_vcode(filename, lookawayThresh)
% Reads looking times (until first lookaway) per trial for a VCode file
% 
% [lookingTimes valid] = read_lookingtime_vcode(filename, lookawayThresh)
%
% filename: path to a VCode text file (generated by File -> Export)
% lookawayThresh: how long a continuous lookaway is required before the
% look is defined to end, in ms
%
% lookingTimes: an array of looking times per trial, in ms
% valid: an array of whether there was actually a valid lookaway, per trial
% (boolean)
% oofDiffs: an array of the difference between looking times per trial when
% out-of-frame periods are treated as looking and when out-of-frame periods
% are treated as lookaways.
%
% The VCode file is expected to include events called 'Trial' or similar
% (see definition of acceptable_trial_names), events called 'Looking' or
% similar (see definition of acceptable_looking_names), and possibly events 
% called 'outofframe' or similar.  All are case-insensitive.  A warning
% will be displayed if any other event types are found, in case they are
% meant to be one of the above types.
% 
% Looking events must be range events.  Trial events may be range events or
% point events.  If they are point events, each trial will be assumed to
% end when the next begins, and the last trial will end at the end of the
% last event of any kind.
%
% Any events that are backwards (the end of the range event is before the
% start) or have a delete note attached to them (see
% acceptable_delete_names) is ignored.
%
% The length of a look is defined as the time from the start of the trial
% or the start of the first look during the trial (whichever is later)
% until the start of the first lookaway at least as long as lookawayThresh.
%  If the child never looks during the trial, the looking time is 0 and the
%  trial is invalid.  If there is no lookaway of sufficient duration, the
%  looking time ends at the trial end (if the child is looking when the
%  trial ends) or at the start of the last lookaway (if the child is not
%  looking when the trial ends).
% Looking coding is overridden during periods of the eyes being out of
% frame.
%
% TODO: doc qualitative
% TODO: doc lookingAtStart
%
% If there are over 3 output arguments specified, then the following are
% computed:
% 
% msArray: a binary array of whether the child is looking this millisecond
%
% trialStartsOut: an array containing the start time of each trial (ms)

    doMsArray = nargout > 5;
    msArray = [];
    trialStarts = [];

    % List variants coders have used for each marking
    acceptable_trial_names = {'Trial', 'Trials', 'trail', 'trails'};
    acceptable_looking_names = {'Looking', 'look', 'looking time', 'lookimg'};
    acceptable_outofframe_names = {'outofframe', 'outoframe', 'outoffame'};
    acceptable_delete_names = {'x', 'delete'};
    
    acceptable_fuss_names = {'Fuss', 'fuss'};
    acceptable_talk_names = {'Talk', 'talk'};
    acceptable_peek_names = {'Peek', 'peek'};
    acceptable_distract_names = {'Distract', 'distract'};
    
    acceptable_other_names = {'sound', 'left', 'right', 'away', 'peeking', 'nosound'};
    
    NEG_THRESH = 10e8;  % Durations greater than this will be assumed negative

    fid = fopen(filename);
    
    doTotal = strcmp(lookawayThresh, 'total');
    if doTotal
        lookawayThresh = 0;
    else
        lookawayThresh = round(lookawayThresh);
    end

    % header
    for i = 1:3
        fgetl(fid);
    end

    formatString = '%d %d %s %s';
    if ispc % different line ending for PCs; none required on Mac
        formatString = [formatString, '\r\n'];
    end
    
    C = textscan(fid, formatString, 'Delimiter', ',');
    fclose(fid);

    starts = C{1};
    [starts, order] = sort(starts);
    durations = C{2}; durations = durations(order);
    types = C{3}; types = types(order); types = strtrim(types);
    marks = C{4}; marks = marks(order); marks = strtrim(marks);
    
    % Remove any marks with a delete note
    exclude = cellfun(@(s)(any(strcmpi(s, acceptable_delete_names))), marks);
    
    % Remove any backwards events
    exclude = exclude | C{2} > NEG_THRESH;
    
    % Update the lists of start/duration/type 
    starts = starts(~exclude);
    durations = durations(~exclude);
    types = types(~exclude);
    
    % Find which events are trials and looks. TODO: generalize across
    % qualitative markings.
    trialInds = cellfun(@(s)(any(strcmpi(s, acceptable_trial_names))), types);
    lookInds  = cellfun(@(s)(any(strcmpi(s, acceptable_looking_names))), types);
    oofInds   = cellfun(@(s)(any(strcmpi(s, acceptable_outofframe_names))), types);
    
    fussInds = cellfun(@(s)(any(strcmpi(s, acceptable_fuss_names))), types);
    peekInds = cellfun(@(s)(any(strcmpi(s, acceptable_peek_names))), types);
    talkInds = cellfun(@(s)(any(strcmpi(s, acceptable_talk_names))), types);
    distractInds = cellfun(@(s)(any(strcmpi(s, acceptable_distract_names))), types);
    
    otherInds = cellfun(@(s)(any(strcmpi(s, acceptable_other_names))), types);
    
    if all(not(trialInds))
        error('No trials recorded for file %s', filename);
    elseif all(not(lookInds))
        warning('No looks recorded for file %s', filename);
    end
    
    if not(all(trialInds | lookInds | oofInds))
        unknownTypes = unique(types(~(trialInds | lookInds | oofInds | otherInds | fussInds | talkInds | distractInds | peekInds)));
        for i = 1:length(unknownTypes)
            warning('Unknown mark type: %s', unknownTypes{i})
        end
    end

    lookStarts = double(starts(lookInds));
    lookEnds = double(starts(lookInds) + durations(lookInds));
    oofStarts = double(starts(oofInds));
    oofEnds   = double(starts(oofInds) + durations(oofInds));
    
    % Deal with either range or point trials
    trialStarts = starts(trialInds);
    if all(durations(trialInds)==0) % point trials
        trialEnds = [trialStarts(2:end); trialStarts(end)+(trialStarts(end)-trialStarts(end-1))];
    else
        trialEnds = starts(trialInds) + durations(trialInds);
    end
    
    % First consolidate looking data--combine any overlapping looks and OOF
    % periods  
    [lookStarts, lookEnds] = consolidate_overlapping(lookStarts, lookEnds);
    [oofStarts, oofEnds]   = consolidate_overlapping(oofStarts,  oofEnds);
    
    % Do the same for qualitative coding (TODO: generalize)
    fussStarts = double(starts(fussInds));
    fussEnds = fussStarts + double(durations(fussInds));
    talkStarts = double(starts(talkInds));
    talkEnds = talkStarts + double(durations(talkInds));
    talkMarks = marks(talkInds);
    peekStarts = double(starts(peekInds));
    peekEnds = peekStarts + double(durations(peekInds));
    distractTimes = double(starts(distractInds));
    [fussStarts, fussEnds] = consolidate_overlapping(fussStarts, fussEnds);
    % Don't consolidate for talk events, to preserve separate transcripts.
    % TODO: possibly consolidate into a separate event for timing purposes.
    %[talkStarts, talkEnds] = consolidate_overlapping(talkStarts, talkEnds);
    [peekStarts, peekEnds] = consolidate_overlapping(peekStarts, peekEnds);
    
    % Now add in the out-of-frame markings.  These take precedence over any
    % looking-time coding.  
    
    removeStarts = false(size(lookStarts));
    removeEnds   = false(size(lookEnds));
    addStarts = [];
    addEnds   = [];
    
    for i = 1:length(oofStarts)
        % Is the child looking at the end of the out-of-frame period?
        lookingAtEnd = any(lookStarts <= oofEnds(i) & lookEnds >= oofEnds(i));
            
        % Remove any look starts and any look ends that happen within this
        % period.  
        removeStarts = removeStarts | lookStarts >= oofStarts(i) & lookStarts <= oofEnds(i);
        removeEnds   = removeEnds   |   lookEnds >= oofStarts(i) & lookEnds   <= oofEnds(i);
        
        % If the child was looking at the end, add a look start at the end
        % of the out-of-frame period.  Otherwise, add a look end there.
        if lookingAtEnd
            addStarts(end+1) = oofEnds(i);
        else
            addEnds(end+1) = oofEnds(i);
        end
        
    end
    
    lookStarts(removeStarts) = [];
    lookEnds(removeEnds) = [];
    lookStarts = [lookStarts; addStarts(:)];
    lookEnds   = [lookEnds;   addEnds(:)];
    
    % Now that we have nonoverlapping looks, we can turn the data into an
    % array of start times of mutually exclusive events: looks and
    % lookaways.  Lookaways are shifted by one because the last frame is
    % included in the look.
    lookEvents = [lookStarts; lookEnds+1; oofStarts];
    % labels: 0 = lookaway, 1 = look, 2 = outofframe
    lookLabels = [ones(size(lookStarts)); zeros(size(lookEnds)); 2*ones(size(oofStarts))];
    [lookEvents, sortIndex] = sort(lookEvents);
    lookLabels = lookLabels(sortIndex);
    
    % Make the ms-by-ms big array of looking-or-not, if needed
    if doMsArray
        msArray = zeros(1, trialEnds(end)+1);
        for iLookEvent = 1:length(lookEvents)
            if iLookEvent == length(lookEvents)
                msArray((lookEvents(iLookEvent)+1):end) = lookLabels(iLookEvent);
            else
                msArray((lookEvents(iLookEvent)+1):lookEvents(iLookEvent+1)) = lookLabels(iLookEvent);
            end
        end
        msArray = msArray(2:end);
        trialStartsOut = trialStarts;
    end
    
    if ~isempty(oofStarts) % some out-of-frame; check impact of these periods
        
        % Make a version with OOF = looking
        lookLabelsA = lookLabels;
        lookLabelsA(lookLabelsA==2) = 1;
        [validA, lookingTimesA, lookStartsA, lookingAtStartA] = ...
            compute_looking_time(trialStarts, trialEnds, lookEvents, lookLabelsA); 
        
        
        % And a version with OOF = lookaway
        lookLabelsB = lookLabels;
        lookLabelsB(lookLabelsB==2) = 0;
        [validB, lookingTimesB, lookStartsB, lookingAtStartB] = ...
            compute_looking_time(trialStarts, trialEnds, lookEvents, lookLabelsB); 
        
        % And compare them: 
        % valid: 0 = invalid, 1 = valid, 2 = validity depends on OOF
        valid = validA;
        valid(validA ~= validB) = 2;
        
        lookingTimes = (lookingTimesA + lookingTimesB)/2;
        oofDiffs = lookingTimesA - lookingTimesB;
        lookStarts = (lookStartsA + lookStartsB)/2;
        lookingAtStart = (lookingAtStartA + lookingAtStartB) / 2; % 0.5 = OOF at start

    else % no out-of-frame; unambiguous looking time
        [valid, lookingTimes, lookStarts, lookingAtStart] = ...
            compute_looking_time(trialStarts, trialEnds, lookEvents, lookLabels);
        oofDiffs = zeros(size(valid));
    end
    
    lookStarts = double(lookStarts(:)');
    
    [fussPeriods, fussTimes] = place_events(lookStarts, lookStarts + lookingTimes, fussStarts, fussEnds);
    [talkPeriods, talkTimes, talkTranscripts] = place_events(lookStarts, lookStarts + lookingTimes, talkStarts, talkEnds, talkMarks);
    [peekPeriods, peekTimes] = place_events(lookStarts, lookStarts + lookingTimes, peekStarts, peekEnds);
    distractPositions = place_point_events(lookStarts, lookStarts + lookingTimes, distractTimes);
    qualitative = struct();
    qualitative.fussPeriods = fussPeriods;
    qualitative.fussTimes = fussTimes;
    qualitative.talkPeriods = talkPeriods;
    qualitative.talkTimes = talkTimes;
    qualitative.peekPeriods = peekPeriods;
    qualitative.peekTimes = peekTimes;
    qualitative.distractPositions = distractPositions;
    qualitative.talkTranscripts = talkTranscripts;
    
    
    function [starts, ends] = consolidate_overlapping(starts, ends)
        % First consolidate looking data--combine any overlapping looks
        changed = true;
        while changed
            changed = false;
            for iLook = 1:length(starts)
                for jLook = [1:(iLook-1), (iLook+1):length(starts)]
                    % does iLook start within jLook? if so, merge these two
                    if starts(iLook) >= starts(jLook) && starts(iLook) <= ends(jLook)
                        % extend jLook if necessary
                        ends(jLook) = max(ends([iLook, jLook]));
                        % and get rid of iLook
                        starts(iLook) = NaN; 
                        ends(iLook) = NaN;
                        % and repeat the process
                        changed = true;
                        continue;
                    end
                end
                if changed
                    continue;
                end
            end
        end

        % Now we should have nonoverlapping looks.  Remove the deleted ones and sort.

        starts = starts(~isnan(starts));
        ends   = ends(~isnan(ends));
        [starts, sortIndex] = sort(starts);
        ends = ends(sortIndex);
    end

    function [timeframes, totals, marksByTrial] = place_events(trialStarts, trialEnds, eventStarts, eventEnds, eventMarks)
       % For range events only; eventMarks optional
        doMarks = nargin > 4;
        if doMarks
            marksByTrial = {};
        end
        
        for iTrial = 1:length(trialStarts)
            % Find the events that overlap this trial at all
            theseEvents = find(not(eventEnds < trialStarts(iTrial)) & ...
                               not(eventStarts > trialEnds(iTrial)));
                      
            timeframes{iTrial} = {};
            totals(iTrial) = 0;
            
            if doMarks
                marksByTrial{iTrial} = eventMarks(theseEvents);
            end
            
            if trialStarts(iTrial) == trialEnds(iTrial)
                continue;
            end
            
            % For each event during this trial, categorize as start,
            % during, end, or entire
            for iEvent = theseEvents(:)'
                if eventStarts(iEvent) <= trialStarts(iTrial)
                    if eventEnds(iEvent) < trialEnds(iTrial)
                        category = 'start';
                    else
                        category = 'entire';
                    end
                else
                    if eventEnds(iEvent) < trialEnds(iTrial)
                        category = 'during';
                    else
                        category = 'end';
                    end
                end
                timeframes{iTrial}{end+1} = category;
                
                % Compute the amount of time this event happened during the
                % trial
                overlappedStart = max(eventStarts(iEvent), trialStarts(iTrial));
                overlappedEnd = min(eventEnds(iEvent), trialEnds(iTrial));
                totals(iTrial) = totals(iTrial) + overlappedEnd - overlappedStart;
                
            end
        end
        
    end

    function [timeBeforeEnd] = place_point_events(trialStarts, trialEnds, eventTimes)
       % For point events only
        
        for iTrial = 1:length(trialStarts)
            % Find the events that overlap this trial at all
            theseEvents = find(eventTimes >= trialStarts(iTrial) & eventTimes <= trialEnds(iTrial));
                      
            if ~isempty(theseEvents)
                timeBeforeEnd{iTrial} = trialEnds(iTrial) - eventTimes(theseEvents);
            else
                timeBeforeEnd{iTrial} = [];
            end
        end
        
    end

    function [valid, lookingTimes, trialStarts, lookingAtStart] = compute_looking_time(trialStarts, trialEnds, lookEvents, lookLabels)
    % Find looking time in each trial.
        for iTrial = 1:length(trialStarts)

            valid(iTrial) = false;

            % Is the child already looking at the start of the trial?
            lastEvent = lookLabels(find(lookEvents<=trialStarts(iTrial), 1, 'last'));
            if isempty(lastEvent), 
                lastEvent = 0; 
            end
            isLooking = lastEvent==1;
            lookingAtStart(iTrial) = isLooking;

            if ~isLooking
                firstLook = find(lookEvents >= trialStarts(iTrial) & ...
                                 lookEvents < trialEnds(iTrial) & ...
                                 lookLabels == 1, 1);
                % If the child isn't looking at the start and doesn't start
                % during the trial, looking time is 0.
                if isempty(firstLook)
                    lookingTimes(iTrial) = 0;
                    continue;
                end
                trialStarts(iTrial) = lookEvents(firstLook);
            end

            isThisTrial = find(lookEvents >= trialStarts(iTrial) & lookEvents <= trialEnds(iTrial));
            theseEvents = lookEvents(isThisTrial);
            theseLabels = lookLabels(isThisTrial);
            
            % If using total looking time, work subtractively--remove
            % lookaways from total time.
            if doTotal
                lookingTimes(iTrial) = trialEnds(iTrial) - trialStarts(iTrial);
            end

            for i = 1:length(isThisTrial)
                if theseLabels(i) == 0
                    if i == length(isThisTrial)
                        lookaway = trialEnds(iTrial) - theseEvents(i);
                    else
                        remainingEvents = theseEvents((i+1):end);
                        remainingLabels = theseLabels((i+1):end);
                        nextLook = find(remainingLabels==1, 1);
                        if isempty(nextLook)
                            lookaway = trialEnds(iTrial) - theseEvents(i);
                        else
                            lookaway = remainingEvents(nextLook) - theseEvents(i);
                        end
                    end

                    if lookaway > lookawayThresh
                        if doTotal
                            lookingTimes(iTrial) = lookingTimes(iTrial) - lookaway;
                        else
                            lookingTimes(iTrial) = theseEvents(i) - trialStarts(iTrial);
                            valid(iTrial) = true;
                            break;
                        end
                    end
                end
            end

            % If there was no valid lookaway record a looking time of the whole
            % trial, but keep the invalid flag.
            if ~valid(iTrial) && ~doTotal
                % If there's any look during the trial...
                if ~isempty(isThisTrial)
                    % If the child is looking at the end of the trial
                    if theseLabels(end)==1  
                        lookingTimes(iTrial) = trialEnds(iTrial) - trialStarts(iTrial);
                    else % If the child is not looking at the end of the trial
                        lookingTimes(iTrial) = theseEvents(end) - trialStarts(iTrial);
                    end
                else
                    lookingTimes(iTrial) = trialEnds(iTrial) - trialStarts(iTrial);
                end
            end

        end
        lookingTimes = double(lookingTimes);
        
    end
    
end