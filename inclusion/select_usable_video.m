function [dataToUse, allLabels, allCounts] = ...
    select_usable_video(data, tasks, showIncompleteCoding)
% Exclude records based on specific criteria; track and display numbers.
%
% [dataToUse, allLabels, allCounts] = ...
%    select_usable_video(data, tasks)
%
% data: standard data structure for Lookit study, generated by 
%     read_lookit_results_xls.
% tasks: Cell array of any of the following tasks, which will be performed
%   in the order given. Example: {{'consent'}, {'uncoded'}, 
%    {'agerange', [36 60]}, {'videousable', 2}}. Possible tasks:
%   
%   {'consent'}: exclude records whose column data.consent is not 'yes'.
%     Creates labels: testaccount (where consent values is 'testaccount';
%     these are not displayed), 'uncoded_consent' (where consent values is 
%     'unknown'), and invalid_consent_VALUE (where consent value=VALUE
%     is anything else besides 'yes').
%
%   {'uncoded'}: exclude records with empty data.allcoders list. Label: 
%      uncoded_main
%
%   {'agerange', [minAgeMonths, maxAgeMonths]}: check dates of birth;
%      flag cases where database and poststudy entries disagree. Exclude
%      children who are younger than minAgeMonths, older than MaxAgeMonths,
%      or who have no valid birthdate entered (age_range_young,
%      age_range_old, and age_range_none, respectively). If data already
%      has the fields 'cleanedageindays' and 'missingBirthdate', then the 
%      cleanedageindays field is used rather than checking that
%      database/poststudy entries agree.
%
%   {'videousable', changerateMin}: exclude records with nonempty value in 
%      data.firstUsability (label = unusable_REASON). If changerateMin > 0, 
%      also exclude records where data.changerate < changerateMin (label
%      unusable_computedframerate).
% 
% [...] = ...
%    select_usable_video(data, tasks, showIncompleteCoding)
%
% showIncompleteCoding: binary, whether to display lists of records that 
%    are coded only 1 time. (Default true)
% 
% dataToUse: what remains after exclusion; same fields as data with the
%   addition (if not already there) of origData, which stores the original
%   data structure including a reasonExcluded field.
% allLabels: cell array of labels for excluded data
% allCounts: counts of how many records excluded, corresponding to
%   allLabels


allLabels = {};
allCounts = [];

if nargin < 3
    showIncompleteCoding = true;
end

fprintf(1, 'Basic exclusion (select_usable_video)\n');

% Go through list of tasks:
for iTask = 1:length(tasks) 
    switch tasks{iTask}{1}
        case 'consent'
            exclude_consent();
        case 'uncoded'
            exclude_uncoded();
        case 'agerange'
            exclude_agerange(tasks{iTask}{2});
        case 'videousable'
            exclude_unusablevideo(tasks{iTask}{2});
        case 'repeat'
            exclude_repeats();
        otherwise
            warning('Unknown task: %s', tasks{iTask}{1});
    end
end

fprintf(1, '\nBasic exclusion complete! N included: %i (%i unique)\n', ...
    length(data.consent), count_unique_participants(data));

fprintf(1, '\t# records, # coders...');
numCoders = cellfun(@(c)length(c), data.allcoders);
[~, ~] = classify_exclusion(numCoders);

uncoded = find(numCoders == 0);
singlecoded = find(numCoders == 1);
if ~isempty(uncoded)
    fprintf(1, 'Uncoded records: \n');
    for i = 1:length(uncoded)
        fprintf('\t %i, recording set %s \n', data.userid(uncoded(i)), data.recordingSet{uncoded(i)});
    end
end
if ~isempty(singlecoded)
    if showIncompleteCoding
        fprintf(1, 'Single-coded records: \n');
        for i = 1:length(singlecoded)
            fprintf('\t %i, recording set %s \n', data.userid(singlecoded(i)), data.recordingSet{singlecoded(i)});
        end
    end
end

dataToUse = data;

fprintf(1, '--------------------------------------------------------------------------------\n');



function exclude_consent()
    
    fprintf(1, '%i. Exclude invalid consent:\n', iTask);
    
    % 0.  Remove 'testaccount' consent records; don't even count these.
    isTestaccount = strcmp(data.consent, 'testaccount');
    nTest = sum(isTestaccount);
    allLabels = [allLabels; {'testaccount'}];
    allCounts = [allCounts; nTest];
    data = set_inclusion(data, ~isTestaccount, 'testaccount');
    fprintf(1, '\t%i testaccount records removed.\n', nTest);

    % 1. Remove records with invalid consent. 
    fprintf(1, '\tTotal records: \t%i (%i unique)\n', length(data.consent), count_unique_participants(data));
    fprintf(1, '\tConsent values...');
    [classified, labels, counts] = classify_exclusion(data.consent, 1);

    % Remove from exclusion counts the ones we CAN use!
    usableInds = ismember(labels, {'yes'});
    labels(usableInds) = [];
    counts(usableInds) = [];

    % Count up and store instances of consent not yet coded
    countEmptyConsent = 0;
    if any(strcmp(labels, ''))
        indEmpty = find(strcmp(labels,''));
        countEmptyConsent = counts(indEmpty);
        % Remove it from the labels/counts list for regular consent issues
        labels(indEmpty) = [];
        counts(indEmpty) = [];
    end

    if any(strcmp(labels, 'unknown'))
        indEmpty = find(strcmp(labels,'unknown'));
        countEmptyConsent = countEmptyConsent + counts(indEmpty);
        % Remove it from the labels/counts list for regular consent issues
        labels(indEmpty) = [];
        counts(indEmpty) = [];
    end

    % Add the invalid consent labels and counts
    labels = cellfun(@(s)['invalid_consent_' s], labels, 'UniformOutput', false);
    allLabels = [allLabels; labels];
    allCounts = [allCounts; counts];

    % Store uncoded consent as a  separate label from other invalid consent
    allLabels = [allLabels; {'uncoded_consent'}];
    allCounts = [allCounts; countEmptyConsent];
    data = set_inclusion(data, ~strcmpi(data.consent, 'unknown'), 'consent_uncoded');

    % Actually exclude based on consent
    data.isConsent  = strcmpi(data.consent, 'yes')';
    data = set_inclusion(data, data.isConsent, 'noconsent');
    
    fprintf(1, '\tUndetermined: \t%i \n', countEmptyConsent);
    fprintf(1, '\tValid consent: \t%i (%i unique)\n', length(data.consent), count_unique_participants(data));

end

function exclude_uncoded()
    fprintf(1, '%i. Exclude uncoded records:\n', iTask);
    
    % 2 (optional).  Remove uncoded records.
    nCoders = cellfun(@(c)length(c), data.allcoders);
    nNotCoded = sum(~nCoders);
    
    fprintf(1, '\tNot yet coded: \t%i \n', nNotCoded);
    
    allLabels = [allLabels; {'uncoded_main'}];
    allCounts = [allCounts; nNotCoded];
    data = set_inclusion(data, logical(nCoders), 'notcoded');
    fprintf(1, '\tCoded: \t%i (%i unique)\n', length(data.consent), count_unique_participants(data));


end

function exclude_agerange(ageRangeMonths)
    %% 3. Remove records out of age range and with unknown ages.

    fprintf(1, '%i. Exclude based on age range:\n', iTask);
    fprintf(1, '\tWarnings about database vs. poststudy DOBs:\n\n');

    % skip this check if we already have data.cleanedageindays and
    % data.missingBirthdate; just assign these on that basis here.
    if isfield(data, 'cleanedageindays') && isfield(data, 'missingBirthdate')
        data.ageindays = data.cleanedageindays;
        fprintf(1, 'Using precomputed ages\n');
    else
        [data.birthdate, data.ageindays, data.missingBirthdate] = check_birthdates(data);
        data.ageindays = data.ageindays(:)';
    end
    data.age = data.ageindays * 12/365;

    tooYoung = data.age < ageRangeMonths(1);
    tooOld   = data.age > ageRangeMonths(2);
    noAge    = isnan(data.age);
    data = set_inclusion(data, ~(tooYoung | tooOld | noAge), 'agerange');
    fprintf(1, '\n\tIn age range: \t\t%i (%i unique)\n', sum(~(tooYoung | tooOld | noAge)), count_unique_participants(data));
    fprintf(1, '\t\tToo young (below %.1f months): \t%i \n', ageRangeMonths(1), sum(tooYoung));
    fprintf(1, '\t\tToo old (above %.1f months): \t%i \n', ageRangeMonths(2), sum(tooOld));
    fprintf(1, '\t\tNo age: \t\t\t%i \n', sum(noAge));

    allLabels = [allLabels; {'age_range_young'; 'age_range_old'; 'age_range_none'}];
    allCounts = [allCounts; sum(tooYoung); sum(tooOld); sum(noAge)];
end

function exclude_unusablevideo(changerateMin) 
    
    % 4. Remove records marked as unusable video (novideo, outofframe, nochild, etc.)
    % Use usability judgments to preemptively exclude those cases where video
    % has been determined to be inadequate for coding or missing:
    fprintf(1, '%i. Exclude based on video usability:\n', iTask);
    
    fprintf(1, '\tVideo_usable labels...\n');
    [classified, labels, counts] = classify_exclusion(data.firstUsability, 1);
    usable = strcmp(data.firstUsability, '') | strcmpi(data.firstUsability, 'yes');

    % Remove from exclusion counts the ones we CAN use!
    usableInds = ismember(labels, {'', 'yes'});
    labels(usableInds) = [];
    counts(usableInds) = [];

    allLabels = [allLabels; (cellfun(@(s)['unusable_' s], labels, 'UniformOutput', false))'];
    allCounts = [allCounts; counts'];
    data = set_inclusion(data, usable, (cellfun(@(s)['unusable_' s], data.firstUsability, 'UniformOutput', false)));

    % 5. Remove records based on computed changerate.
    if changerateMin > 0
        lowframerate = data.changerate < changerateMin;
        framerateCount = sum(lowframerate);
        fprintf(1, '\t Low changerate computed (< %.1f): %i\n', changerateMin, framerateCount);
        data = set_inclusion(data, ~lowframerate, 'unusable_computedframerate');
        allLabels = [allLabels; {'unusable_computedframerate'}];
        allCounts = [allCounts; framerateCount];
        fprintf(1, '\n\tTotal unusable video: %i\n', sum(~usable) + framerateCount);
    end

    fprintf(1, '\tVideo usable: \t\t%i (%i unique)\n', length(data.consent), count_unique_participants(data));
    
end

function exclude_repeats()
    fprintf(1, '%i. Exclude repeat participants:\n', iTask);
    
    % Exclude second (usable) repeat participant - usable data
    excludeRepeat = find_repeats(data);
    countRepeat = sum(excludeRepeat);
    data = set_inclusion(data, ~excludeRepeat, 'repeat');
    allLabels = [allLabels; 'repeat'];
    allCounts = [allCounts; countRepeat];
    fprintf(1, '\tExcluded due to repeat participation: %i\n', countRepeat);
end

end